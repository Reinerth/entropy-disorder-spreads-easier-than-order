<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>disorder spreads easier than order aka predators spread easier than vegans aka bad spreads easier than good</title>

    <style>

        body {
            font-size: 12px;
            font-family: 'system-ui';
        }

        .myImg{
            width: 730px;
        }

        .block{
            width: 90%;
            float: left;
            margin-left: 24px;
            margin-top: 24px;
        }

        .blockTitle, .nameOfSortingAlgorithm {
            width: 230px;
            float: left;
            height: 20px;
            line-height: 20px;
            padding: 5px;
        }
        
        .blockContent, .amountOfMovesToOrder{
            min-height: 20px;
            border: 1px dotted silver;
            line-break: anywhere;
            line-height: 20px;
            padding: 5px;
        }

        .spacer{
            float: left;
            position: relative;
            width: 100%;
            height: 30px;
        }

        #messageToTheUser {
            float: left;
            width: 98%;
            height: 30px;
            color: red;
            font-weight: bold;
        }

        .containerInputAndbutton {
            float: left;
            width: 98%;
            height: 30px;
            margin-left: 24px;
        }

        #myInputAmountOfThings {
            float: left;
            width: 100px;
            height: 26px;
        }

        .containerTitle{
            float: left;
            margin-left: 24px;
            width: 98%;
            height: 19px;
            padding-top: 10px;
        }

        #graphicalItemsOrdered, #graphicalItemsDisordered, #graphicalItemsReOrdered {
            float: left;
            width: 98%;
            height: 160px;
            margin-left: 24px;
        }

        .oneThing {
            float: left;
            border: 1px solid green;
            text-align: center;
        }

        #amountOfMovesToDisorder, #amountOfMovesSortedWithSelectionSort, #amountOfMovesToOrderTitleInsertionSort, #amountOfMovesToOrderTitleQuickSort, #amountOfMovesToOrderTitleBubbleSort, #amountOfMovesToOrderTitleMergeSort, #amountOfMovesToOrderTitleMySimpleSort {
            color: red;
            font-weight: bold;
        }

        #someAdditionalWords {
            float: left;
            width: 98%;
            height: auto;
            margin-left: 24px;
            color: green;
        }

        /* The coolest button in mankinds history ***********************************************/
        /** online-tool for generating gradients: https://www.colorzilla.com/gradient-editor/ **/
        .mySwitch {
            width: 250px;
            height: 30px;
            border: 1px solid #333333;
            line-height: 30px;
            margin-left: 30px;
            position: relative;
            float: left;
            font-weight: bold;
            font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
            text-align: center;
            text-shadow: 0 1px 0px #ffffff;
            white-space: nowrap;
            overflow: hidden;
            padding: 0;
            padding-left: 5px;
            padding-right: 5px;
            /* margin: 0; */
            margin-bottom: 2px;
            cursor: pointer;
            -webkit-border-radius: 3px;
            -moz-border-radius: 3px;
            border-radius: 3px;
            border-top-color: #aeafae;
            border-bottom-color: #7c7e7c;
            -webkit-box-shadow: inset 0px 1px 0px #fbfbfb, inset 1px 0px 0px #ededed, inset 0px -1px 0px #dfdfdf, inset -1px 0px 0px #ededed, 0px 1px 0px rgba(0, 0, 0, 0.15);
            -moz-box-shadow: inset 0px 1px 0px #fbfbfb, inset 1px 0px 0px #ededed, inset 0px -1px 0px #dfdfdf, inset -1px 0px 0px #ededed, 0px 1px 0px rgba(0, 0, 0, 0.15);
            box-shadow: inset 0px 1px 0px #fbfbfb, inset 1px 0px 0px #ededed, inset 0px -1px 0px #dfdfdf, inset -1px 0px 0px #ededed, 0px 1px 0px rgba(0, 0, 0, 0.15);
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#f8f8f8', endColorstr='#bdbdbd');
            background-image: -moz-linear-gradient(top, #f8f8f8, #bdbdbd);
            background-image: -ms-linear-gradient(top, #f8f8f8, #bdbdbd);
            background-image: -webkit-gradient(linear, center top, center bottom, from(#f8f8f8), to(#bdbdbd));
            background-image: -webkit-linear-gradient(top, #f8f8f8, #bdbdbd);
            background-image: -o-linear-gradient(top, #f8f8f8, #bdbdbd);
            background-image: linear-gradient(top, #f8f8f8, #bdbdbd);
        }
        .mySwitch:hover {
            -webkit-box-shadow: inset 0px 1px 0px #fcfcfc, inset 1px 0px 0px #f0f0f0, inset 0px -1px 0px #e4e4e4, inset -1px 0px 0px #f0f0f0, 0px 1px 0px rgba(0, 0, 0, 0.15);
            -moz-box-shadow: inset 0px 1px 0px #fcfcfc, inset 1px 0px 0px #f0f0f0, inset 0px -1px 0px #e4e4e4, inset -1px 0px 0px #f0f0f0, 0px 1px 0px rgba(0, 0, 0, 0.15);
            box-shadow: inset 0px 1px 0px #fcfcfc, inset 1px 0px 0px #f0f0f0, inset 0px -1px 0px #e4e4e4, inset -1px 0px 0px #f0f0f0, 0px 1px 0px rgba(0, 0, 0, 0.15);
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#f8f8f8', endColorstr='#c9c9c9');
            background-image: -moz-linear-gradient(top, #f8f8f8, #c9c9c9);
            background-image: -ms-linear-gradient(top, #f8f8f8, #c9c9c9);
            background-image: -webkit-gradient(linear, center top, center bottom, from(#f8f8f8), to(#c9c9c9));
            background-image: -webkit-linear-gradient(top, #f8f8f8, #c9c9c9);
            background-image: -o-linear-gradient(top, #f8f8f8, #c9c9c9);
            background-image: linear-gradient(top, #f8f8f8, #c9c9c9);
        }

    </style>
</head>




<body>

<br><br>
Things that make me hmm. <br><br>
<u>Some philosophical notes and an abstract experiment about the universal problem of entropy.</u><br><br><br>

I am neither a physicist nor a mathematician, but it is clear and easy to understand,<br>
that building a house of cards, is much harder than destroying it.<br>
That requires no explanation. Or the same with the famous Rubik's Cube,<br>
which I still haven't figured out how to put those damn colors back in place.<br>
That ultimately seems to mean that disorder spreads easier than order.<br>
<br>
And even though I know there is no way out of it, <br>
I wanted to try it by myself if I could cheat at this universal law :-)<br>
I guess the main reason for the entropy-problem might be that we can't remember the way back.<br>
Means, all the footsteps we have walked till the reached point of disorder,<br>
are gone with the wind. It seems to be too expensive to remember them.<br>
<br>
So if I could remember the path I walked to disorder them,<br>
(in a script I could do that, by saving the steps somehow in a list)<br>
I could reorder them, with the "same" amount of steps that I needed to disorder them.<br>
But still the problem of "costs" is there, because remembering the path costs extra moves.<br>
At least on a binary level.<br>
<br>
<br>
<br>
<br>
Just for fun, I wanted to verify the theory by myself<br>
by trying to find a way, to order numbers,<br>
with fewer or the same amount of action moves, than I needed to disorder them.<br>
<br>
For that, I made a list of numbers that initially are sorted.<br>
Then I mix them and count the moves I needed for that.<br>
I count as a move, one step in a loop (I know on a binary level it would be much more).<br>
Finally, I applied different ways of sorting the numbers back.<br>
And again I counted the moves that I needed, to put them back in the place they belong.<br>
<br>
Initially the entropy convinced me to cheat,<br>
so that entropy would have an even greater advantage than it already has,<br>
on counting the amount of moves to disorder,<br>
by directly changing 2 numbers in one loop-step.<br>
This worked out, and I could reduce numbers to half of the length of the array,<br>
and I even could have reduced it to more if I had tried,<br>
but then I found, to be fair, I should have changed the sorting too,<br>
by trying to reposition two numbers in one loop-step.<br>
And this would work only in some rare cases (like explained in "My simple sort").<br>
So I corrected my hack to count the amount of steps in each loop-step.<br>
For both. The order and the disorder.<br>
<br>
So the number of steps for mixing could be reduced more,<br>
but I actually wanted the opposite.<br>
In the end it's just a matter of showing that the number for sorting<br>
cannot be smaller than the number for mixing.<br>
<br>
<br>
<br>
<br>
In reality my experiment could look something like this:<br>
I have an amount of number-cards in my hand (sorted) and I mix them (or simply throw them on the floor).<br>
Then I place them one by one, sorted, into my hand and count the moves for doing that.<br>
<br>
A philosophical difference I found between reality and script:<br>
In reality, we don't need to mix the cards with our hands.<br>
With one single move, we could let the cards fall down to get mixed.<br>
In the script, we need to take every number one by one to put it somewhere else.<br>
In the script there is no gravity or wind that would do the action moves instead.<br>
Could be hard to count those fuzzy wind-moves.<br>
Just imagine the other way around: the cards in your hand are mixed,<br>
you let them fall down, and they fall sorted on a stack. Easy life.<br>
<br>
<br>
<br>
<br>
    <div class="block"><img class="myImg" src="09.png"></div>

    <br><br><br><br>

    <div id="messageToTheUser"></div>
    <div class="containerInputAndbutton">
        <div class="blockTitle"><b>Amount of numbers:</b></div> 
        <input type="text" id="myInputAmountOfThings" value="30">
        <div id="throwTheThingsOnTheFloor" class="mySwitch">Throw the numbers on the floor</div>
    </div>


    <br><br><br><br>

    <div class="block">
        <div class="blockTitle"><b>List of ordered numbers:</b>&nbsp;&nbsp;</div>
        <div class="blockContent" id="orderedNumbersDOM">0</div>

        <div class="blockTitle"><b>List of disordered numbers:&nbsp;&nbsp;</b></div>
        <div class="blockContent" id="disorderedNumbersDOM">0</div>

        <div class="blockTitle"><b>Amount of moves to disorder:</b></div>
        <div class="blockContent" id="amountOfMovesToDisorder">0</div>
    </div>


    <div class="spacer"></div>
    <div class="containerTitle">graphical vizualisation for <u><b>ordered</b></u> items (only if less than 51)</div>
    <div id="graphicalItemsOrdered"></div>
    <div class="containerTitle">graphical vizualisation for <u><b>dis</b></u>ordered items (only if less than 51)</div>
    <div id="graphicalItemsDisordered"></div>
    <div class="spacer"></div>


    <div class="block">
        <div class="nameOfSortingAlgorithm"><b>Sorting algorithm</b></div>
        <div class="amountOfMovesToOrder"><b>Amount of action-moves needed to re-order</b></div>

        <div class="nameOfSortingAlgorithm">Selection sort</div>
        <div class="amountOfMovesToOrder" id="amountOfMovesSortedWithSelectionSort">0</div>

        <div class="nameOfSortingAlgorithm">Insertion sort</div>
        <div class="amountOfMovesToOrder" id="amountOfMovesToOrderTitleInsertionSort">0</div>

        <div class="nameOfSortingAlgorithm">Quick sort</div>
        <div class="amountOfMovesToOrder" id="amountOfMovesToOrderTitleQuickSort">0</div>

        <div class="nameOfSortingAlgorithm">Bubble sort</div>
        <div class="amountOfMovesToOrder" id="amountOfMovesToOrderTitleBubbleSort">0</div>

        <div class="nameOfSortingAlgorithm">Merge sort</div>
        <div class="amountOfMovesToOrder" id="amountOfMovesToOrderTitleMergeSort">0</div>

        <div class="nameOfSortingAlgorithm">My simple sort</div>
        <div class="amountOfMovesToOrder" id="amountOfMovesToOrderTitleMySimpleSort">0</div>

    </div>


    <div class="spacer"></div>
    <div class="containerTitle">graphical vizualisation for <u><b>RE</b></u>-ordered items (only if less than 51)</div>
    <div id="graphicalItemsReOrdered"></div>

    <br><br><br><br>

    <div id="someAdditionalWords">
        <u><b>Some additional excusing words</b></u><br>
<br>
1). Just to be mentioned: I know this abstract, simplified example<br>
works only because of the "clear line we walk", a gapless and clean list of numbers.<br>
It wouldn't work out that easily if we have an irregular order and gaps, letters, colors, or more complex objects.<br>
And I have not analyzed the problem at the depth that I previously called "binary level",<br>
where I would need to count the moves of shifting the bits on the RAM-memory.<br>
<br>
2). The "My simple sort"-algorithm is explained with these unsorted numbers: 3-5-9-6-2-0-1-4-7-8<br>
We loop through those unsorted numbers<br>
and then place each one in a new Array at the index-position where it belongs.<br>
In first place is the number 3<br>
this has to be placed in the new array at the position myArray[3] ==> myArray[_, _, _, 3]<br>
On second place is the number 5<br>
this has to be placed in the new array at the position myArray[5] ==> myArray[_, _, _, 3, _, 5]<br>
and so on ... that's it.<br>
<br>
I am sure not to be the inventor of the "My simple sort",<br>
that I have called "My simple sort" just because I have written it without looking and finding it on the net.<br>
It might already have a name that I don't know.<br>
<br>
"My simple sort" is a kind of cheating, because we don't <u>find</u> the place where they belong,<br>
we <u>know</u> it just because they are numbers in a straight line/list.<br>
It is the same like the idea to remember the walked path. <br>
Our knowledge about the straight line is pendant to the rememberd path.<br>
This "sorting" works only with a gapless list of numbers.<br>
If we had only three numbers to sort like a million, a million and one, and a million and two, <br>
the Array-length would be a million and three, only for those three numbers :-)<br>
<br>
3). All other sorting algorithms have their own strengths that I do not mention here.<br>
One is better at sorting float-numbers or numbers with gaps,<br>
the other is better at sorting alpha-numerical values and so on.<br>
Not of importance in this little experiment.<br>
<br>
4) The script-code is not well-written or well-structured, because it is just a "quick-and-dirty-try".<br>
The focus is on (the difference of) the amounts of action moves for ordering and disordering,<br>
displayed in red in the output.<br>
The goal: a better understanding of the problem I'm living in.<br>




        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
        <br><br><br><br>
    
    
    </div>




    <script>


        /************************************************************************
         * got the different sorting-algorithms from the page geeks-for-geeks.com
         * and some of them were generated from Microsofts-Copilot (Bing). 
         ************************************************************************/

        let orderedNumbers = [];
        let disorderedNumbers0 = [];
        let disorderedNumbers1 = [];
        let disorderedNumbers2 = [];
        let disorderedNumbers3 = [];
        let disorderedNumbers4 = [];
        let disorderedNumbers5 = [];
        let disorderedNumbers6 = [];



        // Clicking on the button "Throw things on the floor"
        document.getElementById("throwTheThingsOnTheFloor").onclick = function(){

            // reset all arrays ...funktioniert aber nicht
            orderedNumbers = [];
            disorderedNumbers0 = [];
            disorderedNumbers1 = [];
            disorderedNumbers2 = [];
            disorderedNumbers3 = [];
            disorderedNumbers4 = [];
            disorderedNumbers5 = [];
            disorderedNumbers6 = [];

            amountOfMovesToOrderWithMergeSort = 0;
            amountOfMovesToOrderWithQuickSort = 0;

            // reset DOM 
            document.getElementById("orderedNumbersDOM").innerText = "0";
            document.getElementById("amountOfMovesToOrderTitleMergeSort").innerText = "0";
            document.getElementById("amountOfMovesToOrderTitleBubbleSort").innerText = "0";
            document.getElementById("amountOfMovesToOrderTitleQuickSort").innerText = "0";
            document.getElementById("amountOfMovesToOrderTitleInsertionSort").innerText = "0";
            document.getElementById("amountOfMovesSortedWithSelectionSort").innerText = "0";
            document.getElementById("amountOfMovesToOrderTitleMySimpleSort").innerText = "0";
            document.getElementById("disorderedNumbersDOM").innerText = "0";
            document.getElementById("amountOfMovesToDisorder").innerText = "0";


            let amountOfThingsToOrder = document.getElementById("myInputAmountOfThings").value;
            let messageToTheUser = document.getElementById("messageToTheUser");

            if (amountOfThingsToOrder >=500){
                messageToTheUser.innerText = "Keep calm, lay back, take a deep breath and try to find back to the roots.";
                return;
            } else {
                messageToTheUser.innerText = "";
            }

            if (amountOfThingsToOrder != "" && amountOfThingsToOrder != 0 && typeof amountOfThingsToOrder != "undefined" && typeof amountOfThingsToOrder != null ){
                amountOfThingsToOrder = document.getElementById("myInputAmountOfThings").value;
            } else {
                amountOfThingsToOrder = 30;
            }

            fillInitialContainerWithThings(amountOfThingsToOrder);
            amountOfThingsToOrder = 0;
        };







        /* create a graphical container for a thing (a number) ***************************************************/

        let makeGraphicalItem = function(myContainerFortheThing, mySize){

            let myThing = document.createElement("div");

            myThing.className = "oneThing";
            // myThing.style.width = "30px";
            myThing.style.width = "20px";;
            myThing.style.height = mySize * 3 + 3 + "px";
            // myThing.style.fontSize = mySize + "px";
            myThing.style.fontSize = "12px";
            myThing.innerText = mySize;


            myContainerFortheThing.appendChild(myThing);
        };







        /* Selection Sort algorithm ***********************************************/
        let selectionSort = function(disorderedNumbers1) {

            let amountOfMovesToOrderWithSelectionSort = 0;
            let n = disorderedNumbers1.length;

            for (let i = 0; i < n - 1; i++) {

                let minIndex = i;

                amountOfMovesToOrderWithSelectionSort++; // increase amount of moves

                for (let j = i + 1; j < n; j++) {

                    amountOfMovesToOrderWithSelectionSort++; // increase amount of moves

                    if (disorderedNumbers1[j] < disorderedNumbers1[minIndex]) {
                        minIndex = j;
                    }
                }

                if (minIndex !== i) {
                    // Swap the elements
                    let temp = disorderedNumbers1[i];
                    disorderedNumbers1[i] = disorderedNumbers1[minIndex];
                    disorderedNumbers1[minIndex] = temp;
                }
            }


            // Only in this sorting algorithm we display them again in DOM for a more intuitive understanding for the user
            let myContainerFortheReorderedThings = document.getElementById("graphicalItemsReOrdered");
            myContainerFortheReorderedThings.innerHTML = ""; // reset the container for the new throw

            if (disorderedNumbers1.length <= 50){ // too many do not fit on the screen an distort the layout 
                for (let oneReOrderedThing=0; oneReOrderedThing<disorderedNumbers1.length; oneReOrderedThing++){
                    makeGraphicalItem(myContainerFortheReorderedThings, disorderedNumbers1[oneReOrderedThing]);
                }
            }

            // Put the amount of action moves to disorder the numbers to DOM
            document.getElementById("amountOfMovesSortedWithSelectionSort").innerText = amountOfMovesToOrderWithSelectionSort;

            return disorderedNumbers1;
        };







        /* Insertion Sort algorithm *****************************************************/
        let insertionSort = function(disorderedNumbers2) {

            let amountOfMovesToOrderWithInsertionSort = 0;
            let n = disorderedNumbers2.length;

            for (let i = 1; i < n; i++) {

                let key = disorderedNumbers2[i];
                let j = i - 1;

                amountOfMovesToOrderWithInsertionSort++; // increase amount of moves

                while (j >= 0 && disorderedNumbers2[j] > key) {

                    amountOfMovesToOrderWithInsertionSort++; // increase amount of moves

                    disorderedNumbers2[j + 1] = disorderedNumbers2[j];
                    j--;
                }

                disorderedNumbers2[j + 1] = key;
            }

            // Put the amount of action moves to disorder the numbers to DOM
            document.getElementById("amountOfMovesToOrderTitleInsertionSort").innerText = amountOfMovesToOrderWithInsertionSort;

            return disorderedNumbers2;
        };



        /* Quick Sort algorithm ***********************************************/

        // Needs to be outside of the function because the function calls itself recursive
        let amountOfMovesToOrderWithQuickSort = 0;

        let quickSort = function(disorderedNumbers3) {


            if (disorderedNumbers3.length <= 1) {
                amountOfMovesToOrderWithQuickSort++
                return disorderedNumbers3;
            }

            const pivot = disorderedNumbers3[disorderedNumbers3.length - 1];
            const left = [];
            const right = [];

            for (let i = 0; i < disorderedNumbers3.length - 1; i++) {

                amountOfMovesToOrderWithQuickSort++;

                if (disorderedNumbers3[i] < pivot) {
                    left.push(disorderedNumbers3[i]);
                } else {
                    right.push(disorderedNumbers3[i]);
                }
            }


            // Put the amount of action moves to disorder the numbers to DOM
            document.getElementById("amountOfMovesToOrderTitleQuickSort").innerText = amountOfMovesToOrderWithQuickSort;

            return [...quickSort(left), pivot, ...quickSort(right)];
        };








        /* Bubble Sort Sort algorithm ***********************************************/

        let bubbleSort = function(disorderedNumbers4) {

            let n = disorderedNumbers4.length;
            let amountOfMovesToOrderWithBubbleSort = 0;
            let swapped = false;

            for(let i = 0;i < n; i++){

                amountOfMovesToOrderWithBubbleSort++;
                swapped = false;

                for(let j = 0 ; j < n - i -1; j++){

                    amountOfMovesToOrderWithBubbleSort++;

                    if( disorderedNumbers4[j] > disorderedNumbers4[j+1]){
                        [disorderedNumbers4[j], disorderedNumbers4[j+1]] = [disorderedNumbers4[j+1], disorderedNumbers4[j]];
                        swapped = true;
                    }
                }

                if( swapped === false) break;
            }


            // Put the amount of action moves to disorder the numbers to DOM
            document.getElementById("amountOfMovesToOrderTitleBubbleSort").innerText = amountOfMovesToOrderWithBubbleSort;

            return disorderedNumbers4;
        };





        /* Merge Sort Sort algorithm ***********************************************/

        // Needs to be outside of the function because the function calls itself recursive
        let amountOfMovesToOrderWithMergeSort = 0;

        let mergeSort = function(disorderedNumbers5) {

            amountOfMovesToOrderWithMergeSort++;

            if (disorderedNumbers5.length <= 1) {
                return disorderedNumbers5;
            }

            const mid = Math.floor(disorderedNumbers5.length / 2);
            const left = mergeSort(disorderedNumbers5.slice(0, mid));
            const right = mergeSort(disorderedNumbers5.slice(mid));

            return merge(left, right);
        };

        let merge = function(left, right) {

            let result = [];
            let i = 0;
            let j = 0;

            while (i < left.length && j < right.length) {

                amountOfMovesToOrderWithMergeSort++;

                if (left[i] < right[j]) {
                    result.push(left[i]);
                    i++;
                } else {
                    result.push(right[j]);
                    j++;
                }
            }

            // Put the amount of action moves to disorder the numbers to DOM
            document.getElementById("amountOfMovesToOrderTitleMergeSort").innerText = amountOfMovesToOrderWithMergeSort;

            return result.concat(left.slice(i), right.slice(j));
        };



        /* mySimpleSort Sort algorithm ***********************************************/

        // Example for this unsorted numbers 3-5-9-6-2-0-1-4-7-8
        // We create a new empty Array where we place our sorted numbers.
        // Now we loop through those unsorted.
        // On first place is the number 3
        // this has to be placed in the new array at the position myArray[3]
        // On second place is the number 5
        // this has to be placed in the new array at the position myArray[5]
        // and so on ...

        let mySimpleSort = function(disorderedNumbers6) {

            let amountDisorderedNumbers6 = disorderedNumbers6.length;
            let amountOfMovesToOrderTitleMySimpleSort = 0;
            let orderedNumbers6 = [];

            for(let myNum6 = 0; myNum6 < amountDisorderedNumbers6; myNum6++){

                amountOfMovesToOrderTitleMySimpleSort++;
                orderedNumbers6[disorderedNumbers6[myNum6]] = disorderedNumbers6[myNum6];
            }

            // Put the amount of action moves to disorder the numbers to DOM
            document.getElementById("amountOfMovesToOrderTitleMySimpleSort").innerText = amountOfMovesToOrderTitleMySimpleSort + "  (kind of cheating - see additional notes below pt 2)";

            // console.log(disorderedNumbers6);
            // console.log(orderedNumbers6); // it works

            return orderedNumbers6;
        };



        /* Disorder numbers in list *******************************************************************/

        let disorderNumbers = function(orderedNumbers){

            let amountOfMovestoDisorder = 0;

            let amountOfNeededLoopes = orderedNumbers.length;

            for (let i = amountOfNeededLoopes - 1; i > 0; i--) {

                amountOfMovestoDisorder++;

                const j = Math.floor(Math.random() * (i + 1));

                [orderedNumbers[i], orderedNumbers[j]] = [orderedNumbers[j], orderedNumbers[i]];
            }

            // Put the disordered nubers to DOM
            document.getElementById("disorderedNumbersDOM").innerText = orderedNumbers;
            // Put the amount of moves to disorder the nubers to DOM
            document.getElementById("amountOfMovesToDisorder").innerText = amountOfMovestoDisorder + 1;


            let myContainerFortheThing = document.getElementById("graphicalItemsDisordered");
            myContainerFortheThing.innerHTML = ""; // reset the container for the new throw

            if (orderedNumbers.length <= 50){ // too many do not fit on the screen an distort the layout 
                for (let oneDisorderedThing=0; oneDisorderedThing<orderedNumbers.length; oneDisorderedThing++){
                    makeGraphicalItem(myContainerFortheThing, orderedNumbers[oneDisorderedThing]);
                }
            }
        };

        // The old version -> cheating for the double-advantage of entropy
        // Check if amount of things are even 
        // let isEven = function(myNumber){
        //     return myNumber % 2 === 0;
        // };

        // let disorderNumbers = function(orderedNumbers){

        //     let amountOfMovestoDisorder = 0;

        //     // We can half the amount of loops, 
        //     // because in every loop we swap two numbers. 
        //     // For that we need to find out if the length is even,
        //     // and if not still take the half of the amount minus one 
        //     // and add the uneven to the needed amount of loops.
        //     // The "action moves" could get lowered with this idea.
        //     // In reality we would need only one move to throw the numbers on the floor,
        //     // doesnt matter if they were 50 or 100.
        //     // But we dont have that magic here, so we go the long way. 
        //     let amountOfNeededLoopes = orderedNumbers.length;

        //     if (isEven(amountOfNeededLoopes) == true){
        //         amountOfNeededLoopes = amountOfNeededLoopes/2;
        //     } else {
        //         amountOfNeededLoopes = ((amountOfNeededLoopes-1)/2)+1;
        //     }

        //     for (let oneNumber=0; oneNumber<amountOfNeededLoopes; oneNumber++){

        //         amountOfMovestoDisorder++; 

        //         // pick randomly a number from the list of sorted numbers 
        //         let indexOfFirstRandomNumer = Math.floor(Math.random() * orderedNumbers.length);
        //         let myRandomNumber1 = orderedNumbers[indexOfFirstRandomNumer];

        //         // pick randomly a second number from the list of sorted numbers 
        //         let indexOfSecondRandomNumer = Math.floor(Math.random() * orderedNumbers.length);
        //         let myRandomNumber2 = orderedNumbers[indexOfSecondRandomNumer];

        //         // switch/swap the places of the both numbers in list
        //         orderedNumbers[indexOfFirstRandomNumer] = myRandomNumber2; 
        //         orderedNumbers[indexOfSecondRandomNumer] = myRandomNumber1; 
        //     }

        //     // Put the disordered nubers to DOM
        //     document.getElementById("disorderedNumbersDOM").innerText = orderedNumbers;
        //     // Put the amount of moves to disorder the nubers to DOM
        //     document.getElementById("amountOfMovesToDisorder").innerText = amountOfMovestoDisorder;


        //     let myContainerFortheThing = document.getElementById("graphicalItemsDisordered");
        //     myContainerFortheThing.innerHTML = ""; // reset the container for the new throw

        //     if (orderedNumbers.length <= 50){ // too many do not fit on the screen an distort the layout 
        //         for (let oneDisorderedThing=0; oneDisorderedThing<orderedNumbers.length; oneDisorderedThing++){
        //             makeGraphicalItem(myContainerFortheThing, orderedNumbers[oneDisorderedThing]);
        //         }
        //     }
        // };






        /* fill initial container (list) with things (numbers) *****************************************************/

        let fillInitialContainerWithThings = function(amountOfThingsToOrder){

            let myContainerFortheThing = document.getElementById("graphicalItemsOrdered");
            myContainerFortheThing.innerHTML = ""; // reset the container for the new throw

            for (let oneThing=0; oneThing<amountOfThingsToOrder; oneThing++){

                orderedNumbers.push(oneThing); // put one thing after another to the container

                if (amountOfThingsToOrder <= 50){ // too many do not fit on the screen an distort the layout 
                    // visualisation of the things
                    makeGraphicalItem(myContainerFortheThing, oneThing);
                }


                if(oneThing == amountOfThingsToOrder-1){ // ready, container is filled up

                    // put the ordered nubers to DOM 
                    document.getElementById("orderedNumbersDOM").innerText = orderedNumbers;

                    // and throw them then on the floor
                    disorderNumbers(orderedNumbers);

                    // ugly workaround fo duplicating the lists
                    for (let oneThingily=0; oneThingily<orderedNumbers.length; oneThingily++){

                        disorderedNumbers0.push(orderedNumbers[oneThingily]);
                        disorderedNumbers1.push(orderedNumbers[oneThingily]);
                        disorderedNumbers2.push(orderedNumbers[oneThingily]);
                        disorderedNumbers3.push(orderedNumbers[oneThingily]);
                        disorderedNumbers4.push(orderedNumbers[oneThingily]);
                        disorderedNumbers5.push(orderedNumbers[oneThingily]);
                        disorderedNumbers6.push(orderedNumbers[oneThingily]);

                        if(oneThingily == orderedNumbers.length-1){ // ready, containers are filled up

                            // now re-order them again
                            selectionSort(disorderedNumbers1);
                            insertionSort(disorderedNumbers2);
                            quickSort(disorderedNumbers3);
                            bubbleSort(disorderedNumbers4);
                            mergeSort(disorderedNumbers5); 
                            mySimpleSort(disorderedNumbers6); 
                        }
                    }
                }
            }
        };








    </script>
</body>

</html>
